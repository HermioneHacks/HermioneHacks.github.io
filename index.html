<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Roommate Chores • Rotation System</title>
  <link rel="stylesheet" href="styles.css">
  <!-- React 18 UMD + ReactDOM -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <!-- Babel for JSX (development convenience). For production, consider prebuilding. -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-gray-50">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useMemo } = React;

    const STORAGE_KEY = "roommate_chores_app_v2_with_optional";

    function useLocalStorageState(defaultValue) {
      const [state, setState] = useState(() => {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (raw) {
            const parsed = JSON.parse(raw);
            // Migration: if old structure exists, convert to new structure
            if (parsed.queue && !parsed.queue3pm) {
              parsed.queue3pm = [...parsed.queue];
              parsed.queueNight = [...parsed.queue].reverse();
              delete parsed.queue;
            }
            // Migration: ensure bathrooms exist
            if (!parsed.bathrooms) {
              parsed.bathrooms = defaultState.bathrooms;
            }
            return parsed;
          }
          return defaultValue;
        } catch {
          return defaultValue;
        }
      });
      useEffect(() => {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        } catch {}
      }, [state]);
      return [state, setState];
    }

    const defaultState = {
      roommates: ["Khushi", "Kavya", "Himani", "Avani"],
      queue3pm: ["Khushi", "Kavya", "Himani", "Avani"], // Forward rotation
      queueNight: ["Avani", "Himani", "Kavya", "Khushi"], // Backward rotation
      optionalChores: {
        "Cleaned Microwave": {
          points: 0.5,
          description: "Clean inside and outside of microwave"
        },
        "Cleaned Counters and Bar": {
          points: 1.0,
          description: "Wipe down kitchen counters and bar area"
        },
        "Towels Laundry": {
          points: 1.5,
          description: "Wash, dry, and fold towels"
        },
        "Cleaned Stove": {
          points: 1.0,
          description: "Clean stove top and oven"
        },
        "Cleaned Fridge": {
          points: 1.5,
          description: "Clean inside and outside of refrigerator"
        },
        "Cleaned Couches": {
          points: 1.0,
          description: "Vacuum and clean couch surfaces"
        },
        "Cleaned TV and Tables": {
          points: 0.5,
          description: "Dust and clean TV area and tables"
        },
        "Swiffered": {
          points: 0.5,
          description: "Swiffer floors throughout the house"
        },
        "Swept/Vacuumed": {
          points: 1.0,
          description: "Sweep or vacuum floors"
        },
        "Fixed Couch": {
          points: 2.0,
          description: "Fix couch cushions, covers, or other couch issues"
        },
        "Other": {
          points: 1.0,
          description: "Other household tasks not listed above"
        }
      },
      bathrooms: {
        "Bathroom 1": {
          pair: ["Kavya", "Avani"],
          currentResponsible: "Kavya",
          lastCleaned: null,
          lastCleanedBy: null
        },
        "Bathroom 2": {
          pair: ["Himani", "Khushi"],
          currentResponsible: "Himani",
          lastCleaned: null,
          lastCleanedBy: null
        }
      },
      paused: {},
      credits: {},
      history: [],
      pins: {
        "Khushi": "1111",
        "Kavya": "2222", 
        "Himani": "2024",
        "Avani": "3333"
      },
    };

    const Label = ({ children }) => (
      <span className="inline-flex items-center rounded-full px-3 py-1 text-xs font-medium bg-gray-100">
        {children}
      </span>
    );

    function Section({ title, children, extra }) {
      return (
        <div className="rounded-2xl shadow-sm border p-4 bg-white">
          <div className="flex items-start justify-between gap-2 mb-3">
            <h2 className="text-lg font-semibold">{title}</h2>
            {extra}
          </div>
          {children}
        </div>
      );
    }

    function DishwasherApp() {
      const [state, setState] = useLocalStorageState(defaultState);
      const [showAdminPanel, setShowAdminPanel] = useState(false);
      const [adminPassword, setAdminPassword] = useState("");
      const [currentUser, setCurrentUser] = useState(null);
      const [isGuest, setIsGuest] = useState(false);
      const [showLoginModal, setShowLoginModal] = useState(true);
      const [loginPin, setLoginPin] = useState("");
      const [loginError, setLoginError] = useState("");
      const [conflicts, setConflicts] = useState([]);
      const [pauseRequests, setPauseRequests] = useState([]);
      const [showCollaborationModal, setShowCollaborationModal] = useState(false);
      const [pendingChoreClaim, setPendingChoreClaim] = useState(null);
      const [selectedCollaborators, setSelectedCollaborators] = useState([]);
      const [pendingOtherChores, setPendingOtherChores] = useState([]);

      // Function to check for roommate call-outs
      function getRoommateCallouts() {
        const callouts = [];
        const now = new Date();
        const cstNow = new Date(now.toLocaleString("en-US", {timeZone: "America/Chicago"}));
        
        // Check for roommates who haven't done their responsible shift by the next shift
        const recentHistory = history.filter(h => {
          const entryDate = new Date(h.when);
          const cstEntryDate = new Date(entryDate.toLocaleString("en-US", {timeZone: "America/Chicago"}));
          const hoursDiff = (cstNow - cstEntryDate) / (1000 * 60 * 60);
          return hoursDiff <= 72; // Check last 72 hours for better detection
        });
        
        // Check 3PM shifts
        const threePMEntries = recentHistory.filter(h => h.kind === '3pm');
        const nightEntries = recentHistory.filter(h => h.kind === 'night');
        
        // Check if current 3PM person hasn't done their shift
        if (current3pm) {
          const threePMHistory = threePMEntries.filter(h => 
            h.runBy === current3pm || h.unloadBy === current3pm
          );
          
          if (threePMHistory.length === 0) {
            // Check if they've been at the top for too long
            const lastThreePMEntry = threePMEntries[threePMEntries.length - 1];
            if (lastThreePMEntry) {
              const lastEntryDate = new Date(lastThreePMEntry.when);
              const cstLastEntryDate = new Date(lastEntryDate.toLocaleString("en-US", {timeZone: "America/Chicago"}));
              const hoursSinceLastThreePM = (cstNow - cstLastEntryDate) / (1000 * 60 * 60);
              
              // If it's been more than 36 hours since last 3PM shift, call out current person
              if (hoursSinceLastThreePM > 36) {
                callouts.push({
                  type: 'missed_shift',
                  roommate: current3pm,
                  shift: '3PM',
                  reason: `Hasn't done their 3PM shift in over 36 hours`
                });
              }
            } else {
              // No 3PM entries in recent history, call out current person
              callouts.push({
                type: 'missed_shift',
                roommate: current3pm,
                shift: '3PM',
                reason: `Hasn't done their 3PM shift - no recent 3PM activity`
              });
            }
          }
        }
        
        // Check if current Night person hasn't done their shift
        if (currentNight) {
          const nightHistory = nightEntries.filter(h => 
            h.runBy === currentNight || h.unloadBy === currentNight
          );
          
          if (nightHistory.length === 0) {
            // Check if they've been at the top for too long
            const lastNightEntry = nightEntries[nightEntries.length - 1];
            if (lastNightEntry) {
              const lastEntryDate = new Date(lastNightEntry.when);
              const cstLastEntryDate = new Date(lastEntryDate.toLocaleString("en-US", {timeZone: "America/Chicago"}));
              const hoursSinceLastNight = (cstNow - cstLastEntryDate) / (1000 * 60 * 60);
              
              // If it's been more than 36 hours since last night shift, call out current person
              if (hoursSinceLastNight > 36) {
                callouts.push({
                  type: 'missed_shift',
                  roommate: currentNight,
                  shift: 'Night',
                  reason: `Hasn't done their Night shift in over 36 hours`
                });
              }
            } else {
              // No night entries in recent history, call out current person
              callouts.push({
                type: 'missed_shift',
                roommate: currentNight,
                shift: 'Night',
                reason: `Hasn't done their Night shift - no recent night activity`
              });
            }
          }
        }
        
        // Check for roommates who haven't done any optional chores in 7 days
        const sevenDaysAgo = new Date(cstNow.getTime() - (7 * 24 * 60 * 60 * 1000));
        
        roommates.forEach(roommate => {
          const recentOptionalChores = history.filter(h => 
            h.completedBy === roommate && 
            !h.kind && // Optional chores don't have 'kind'
            new Date(h.when) > sevenDaysAgo
          );
          
          if (recentOptionalChores.length === 0) {
            callouts.push({
              type: 'no_optional_chores',
              roommate: roommate,
              reason: `Hasn't done any optional chores in 7 days`
            });
          }
        });
        
        return callouts;
      }

      // Get current date and time in CST
      function getCurrentDateTime() {
        const now = new Date();
        const cstTime = new Date(now.toLocaleString("en-US", {timeZone: "America/Chicago"}));
        
        const months = ["January", "February", "March", "April", "May", "June", 
                       "July", "August", "September", "October", "November", "December"];
        const month = months[cstTime.getMonth()];
        const day = cstTime.getDate();
        const year = cstTime.getFullYear();
        
        const hour = cstTime.getHours();
        let greeting;
        if (hour < 12) {
          greeting = "Good morning";
        } else if (hour < 17) {
          greeting = "Good afternoon";
        } else if (hour < 22) {
          greeting = "Good evening";
        } else {
          greeting = "Good night";
        }
        
        const timeString = cstTime.toLocaleTimeString("en-US", {
          timeZone: "America/Chicago",
          hour: "numeric",
          minute: "2-digit",
          hour12: true
        });
        
        return {
          dateString: `${month} ${day}, ${year}`,
          greeting,
          timeString
        };
      }
      
      // Ensure new chore structure exists
      const safeState = {
        ...defaultState,
        ...state,
        queue3pm: state.queue3pm || defaultState.queue3pm,
        queueNight: state.queueNight || defaultState.queueNight,
        optionalChores: state.optionalChores || defaultState.optionalChores,
        bathrooms: state.bathrooms || defaultState.bathrooms,
      };


      
      const { roommates, queue3pm, queueNight, optionalChores, bathrooms, paused, credits, history, pins } = safeState;

      const activeQueue3pm = useMemo(
        () => queue3pm.filter((n) => !paused[n]),
        [queue3pm, paused]
      );

      const activeQueueNight = useMemo(
        () => queueNight.filter((n) => !paused[n]),
        [queueNight, paused]
      );

      useEffect(() => {
        const updatedCredits = { ...credits };
        const updatedPins = { ...pins };
        roommates.forEach((r) => {
          if (updatedCredits[r] == null) updatedCredits[r] = 0;
          if (updatedPins[r] == null) updatedPins[r] = "";
        });
        if (
          JSON.stringify(updatedCredits) !== JSON.stringify(credits) ||
          JSON.stringify(updatedPins) !== JSON.stringify(pins)
        ) {
          setState((s) => ({ ...s, credits: updatedCredits, pins: updatedPins }));
        }
      }, [roommates]);

      const current3pm = activeQueue3pm[0] || null;
      const next3pm = activeQueue3pm[1] || null;
      const currentNight = activeQueueNight[0] || null;
      const nextNight = activeQueueNight[1] || null;

      function handleLogin() {
        setLoginError("");
        const enteredPin = loginPin.trim();
        
        if (!enteredPin) {
          setLoginError("Please enter your PIN");
          return;
        }
        
        // Check if PIN matches any roommate
        const matchedUser = roommates.find(name => pins[name] === enteredPin);
        
        if (matchedUser) {
          setCurrentUser(matchedUser);
          setShowLoginModal(false);
          setLoginPin("");
        } else {
          setLoginError("Invalid PIN. Please try again.");
        }
      }

      function handleGuestMode() {
        setIsGuest(true);
        setCurrentUser("Guest");
        setShowLoginModal(false);
        setLoginPin("");
        setLoginError("");
      }

      function handleLogout() {
        setCurrentUser(null);
        setIsGuest(false);
        setShowLoginModal(true);
        setLoginPin("");
        setLoginError("");
      }

      function advanceQueue3pm() {
        if (!activeQueue3pm.length) return;
        const rotated = [...activeQueue3pm.slice(1), activeQueue3pm[0]];
        const full = rotated.concat(state.queue3pm.filter((n) => paused[n]));
        setState((s) => ({ ...s, queue3pm: full }));
      }

      function advanceQueueNight() {
        if (!activeQueueNight.length) return;
        const rotated = [...activeQueueNight.slice(1), activeQueueNight[0]];
        const full = rotated.concat(state.queueNight.filter((n) => paused[n]));
        setState((s) => ({ ...s, queueNight: full }));
      }

      function requestPause(name) {
        const isCurrentlyPaused = paused[name];
        const action = isCurrentlyPaused ? "unpause" : "pause";
        
        const request = {
          id: Math.random().toString(36).slice(2),
          name,
          action,
          timestamp: new Date().toISOString(),
          status: "pending"
        };
        
        setPauseRequests(prev => [...prev, request]);
        
        if (currentUser === "Himani") {
          // Admin can approve immediately
          if (confirm(`${name} wants to ${action}. Approve now?`)) {
            approvePauseRequest(request.id);
          }
        } else {
          alert(`Pause request sent to admin. ${name} will be ${action}d once approved.`);
        }
      }

      function approvePauseRequest(requestId) {
        const request = pauseRequests.find(r => r.id === requestId);
        if (!request) return;
        
        setState((s) => {
          const p = { ...s.paused, [request.name]: request.action === "pause" };
          return { ...s, paused: p };
        });
        
        setPauseRequests(prev => prev.map(r => 
          r.id === requestId ? { ...r, status: "approved" } : r
        ));
      }

      function rejectPauseRequest(requestId) {
        setPauseRequests(prev => prev.map(r => 
          r.id === requestId ? { ...r, status: "rejected" } : r
        ));
      }

      function approveOtherChore(choreId) {
        const chore = pendingOtherChores.find(c => c.id === choreId);
        if (!chore) return;
        
        // Claim the chore with the collaborators that were already selected
        claimOptionalChore(chore.choreName, chore.completedBy, chore.collaborators || []);
        
        // Mark as approved
        setPendingOtherChores(prev => prev.map(c => 
          c.id === choreId ? { ...c, status: "approved" } : c
        ));
        
        alert(`Approved: "${chore.choreName}" completed by ${chore.completedBy}${chore.collaborators && chore.collaborators.length > 0 ? ` with ${chore.collaborators.join(', ')}` : ''}`);
      }

      function rejectOtherChore(choreId) {
        setPendingOtherChores(prev => prev.map(c => 
          c.id === choreId ? { ...c, status: "rejected" } : c
        ));
      }

      function setPin(name, pinRaw) {
        const currentUser = prompt("Enter your name to set PIN:");
        if (currentUser === name) {
        const pin = (pinRaw || "").trim();
        if (pin && !/^[0-9]{4,8}$/.test(pin)) {
          alert("PIN must be 4–8 digits.");
          return;
        }
        setState((s) => ({ ...s, pins: { ...s.pins, [name]: pin } }));
        } else if (currentUser !== null) {
          const password = prompt("Enter admin password to set PINs:");
          if (password !== "Himani2024") {
            alert("Incorrect admin password. Only Himani can set PINs for others.");
            return;
          }
          const pin = (pinRaw || "").trim();
          if (pin && !/^[0-9]{4,8}$/.test(pin)) {
            alert("PIN must be 4–8 digits.");
            return;
          }
          setState((s) => ({ ...s, pins: { ...s.pins, [name]: pin } }));
        }
      }

      function requirePinFor(name) {
        const expected = (pins[name] || "").trim();
        if (!expected) return true;
        const entered = prompt(`Enter PIN for ${name}`)?.trim();
        if (entered === expected) return true;
        alert("Incorrect PIN.");
        return false;
      }

      function checkForConflicts(kindOrChore, action, person) {
        // Check if someone else already claimed this task recently (within last 2 hours for dishwasher, 1 hour for optional chores)
        const timeWindow = kindOrChore === '3pm' || kindOrChore === 'night' ? 2 * 60 * 60 * 1000 : 60 * 60 * 1000;
        const timeAgo = new Date(Date.now() - timeWindow);
        
        const recentHistory = history.filter(h => {
          if (kindOrChore === '3pm' || kindOrChore === 'night') {
            return h.kind === kindOrChore && new Date(h.when) > timeAgo;
          } else {
            return h.choreName === kindOrChore && new Date(h.when) > timeAgo;
          }
        });
        
        const conflictingEntry = recentHistory.find(h => {
          // Only check for conflicts on the same action type
          if (action === 'run' && h.runBy === person) return false; // Same person, no conflict
          if (action === 'unload' && h.unloadBy === person) return false; // Same person, no conflict
          if (action === 'complete' && h.completedBy === person) return false; // Same person, no conflict
          if (action === 'run' && h.runBy && h.runBy !== person) return true; // Different person claimed run
          if (action === 'unload' && h.unloadBy && h.unloadBy !== person) return true; // Different person claimed unload
          if (action === 'complete' && h.completedBy && h.completedBy !== person) return true; // Different person claimed completion
          return false;
        });
        
        if (conflictingEntry) {
          const conflict = {
            id: Math.random().toString(36).slice(2),
            kindOrChore,
            action,
            newClaim: person,
            existingClaim: action === 'run' ? conflictingEntry.runBy : 
                         action === 'unload' ? conflictingEntry.unloadBy : 
                         conflictingEntry.completedBy,
            timestamp: new Date().toISOString(),
            resolved: false
          };
          setConflicts(prev => [...prev, conflict]);
          return true;
        }
        return false;
      }

      function addCredits({ runBy, unloadBy, kind }) {
        console.log('addCredits called with:', { runBy, unloadBy, kind, unloadByType: typeof unloadBy, unloadByNull: unloadBy === null });
        const currentPerson = kind === '3pm' ? activeQueue3pm[0] : activeQueueNight[0];
        
        // Determine the scenario and assign points accordingly
        let runCredit = 0.5;
        let unloadCredit = 0.5;
        let currentPersonDidSomething = false;
        
        if (runBy && unloadBy && unloadBy !== null) {
          // Both tasks completed
          if (runBy === currentPerson && unloadBy === currentPerson) {
            // Current person did both - standard rate
            runCredit = 0.5;
            unloadCredit = 0.5;
            currentPersonDidSomething = true;
          } else if (runBy === currentPerson || unloadBy === currentPerson) {
            // Current person did one, someone else did the other - helper gets bonus
            if (runBy === currentPerson) {
              // Current person ran, someone else unloaded
              runCredit = 0.5;
              unloadCredit = 0.8; // Bonus for helper
              currentPersonDidSomething = true;
            } else {
              // Current person unloaded, someone else ran
              runCredit = 0.8; // Bonus for helper
              unloadCredit = 0.5;
              currentPersonDidSomething = true;
            }
          } else {
            // Someone else did both - standard rate for helper, current person stays accountable
            runCredit = 0.5;
            unloadCredit = 0.5;
            currentPersonDidSomething = false;
          }
        } else if (runBy && (!unloadBy || unloadBy === null)) {
          // Only run completed
          if (runBy === currentPerson) {
            runCredit = 0.5;
            currentPersonDidSomething = true;
          } else {
            runCredit = 0.5;
            currentPersonDidSomething = false;
          }
        } else if (unloadBy && (!runBy || runBy === null)) {
          // Only unload completed
          if (unloadBy === currentPerson) {
            unloadCredit = 0.5;
            currentPersonDidSomething = true;
          } else {
            unloadCredit = 0.5;
            currentPersonDidSomething = false;
          }
        }
        
        return {
          runCredit,
          unloadCredit,
          currentPersonDidSomething
        };
      }

      function claimOptionalChore(choreName, completedBy, collaborators = []) {
        // For "Other" chores, use default 1.0 points, otherwise get from optionalChores
        const chore = optionalChores[choreName];
        const totalPoints = chore ? chore.points : 1.0; // Default 1.0 for custom chores
        
        setState((s) => {
          const c = { ...s.credits };
          
          if (collaborators.length > 0) {
            // Distribute points evenly among all collaborators
            const pointsPerPerson = totalPoints / (collaborators.length + 1); // +1 for the main person
            c[completedBy] = (c[completedBy] ?? 0) + pointsPerPerson;
            collaborators.forEach(collaborator => {
              c[collaborator] = (c[collaborator] ?? 0) + pointsPerPerson;
            });
          } else {
            // Single person gets all points
            c[completedBy] = (c[completedBy] ?? 0) + totalPoints;
          }
          
          const entry = {
            id: Math.random().toString(36).slice(2),
            when: new Date().toISOString(),
            choreName,
            completedBy,
            collaborators,
            points: totalPoints,
            pointsPerPerson: collaborators.length > 0 ? totalPoints / (collaborators.length + 1) : totalPoints,
            description: chore ? chore.description : "Custom chore"
          };
          
          return { ...s, credits: c, history: [entry, ...s.history].slice(0, 200) };
        });
      }

      function completeLoad(kind, { runBy, unloadBy, advance = true }) {
        const currentPerson = kind === '3pm' ? activeQueue3pm[0] : activeQueueNight[0];
        
        // Calculate credits and determine if current person did something
        const { runCredit, unloadCredit, currentPersonDidSomething } = addCredits({ runBy, unloadBy, kind });
        
        setState((s) => {
          const c = { ...s.credits };
          
          // Apply credits
          if (runBy) {
            c[runBy] = (c[runBy] ?? 0) + runCredit;
          }
          if (unloadBy) {
            c[unloadBy] = (c[unloadBy] ?? 0) + unloadCredit;
          }
          
          // Create history entry
          const entry = {
            id: Math.random().toString(36).slice(2),
            when: new Date().toISOString(),
            kind,
            runBy,
            unloadBy,
            runCredit,
            unloadCredit,
            isFavor: (runBy !== currentPerson || unloadBy !== currentPerson),
            currentPersonDidSomething
          };
          
          // Queue advancement logic:
          // 1. If current person did at least one task, they move to bottom
          // 2. If someone else did both tasks, current person stays at top (held accountable)
          // 3. If current person did one task and someone else did the other, current person moves to bottom
          let newState = { ...s, credits: c, history: [entry, ...s.history].slice(0, 200) };
          
          if (advance && currentPersonDidSomething) {
            if (kind === '3pm') {
              const rotated = [...s.queue3pm.slice(1), s.queue3pm[0]];
              const full = rotated.concat(s.queue3pm.filter((n) => s.paused[n]));
              newState = { ...newState, queue3pm: full };
            } else if (kind === 'night') {
              const rotated = [...s.queueNight.slice(1), s.queueNight[0]];
              const full = rotated.concat(s.queueNight.filter((n) => s.paused[n]));
              newState = { ...newState, queueNight: full };
            }
          }
          // If current person did nothing, queue doesn't advance (they stay at the top)
          
          return newState;
        });
      }

      function handleComplete(kind) {
        // Check if current user is paused
        if (paused[currentUser]) {
          alert(`❌ You are currently paused and cannot claim tasks. Please contact admin to unpause you.`);
          return;
        }
        
        // Since user is already logged in with PIN, automatically use current user
        const runBy = currentUser;
        const unloadBy = currentUser;
        
        // Check for conflicts before proceeding
        if (checkForConflicts(kind, 'run', runBy) || checkForConflicts(kind, 'unload', unloadBy)) {
          alert(`⚠️ CONFLICT DETECTED!\n\nSomeone else already claimed they did the ${kind === '3pm' ? '3 PM' : 'Night'} load.\n\nThis conflict has been logged for admin review.`);
          return;
        }
        
        completeLoad(kind, { runBy, unloadBy, advance: true });
      }

      function handleClaimChore(choreName) {
        // Check if current user is paused
        if (paused[currentUser]) {
          alert(`❌ You are currently paused and cannot claim tasks. Please contact admin to unpause you.`);
          return;
        }
        
        // Since user is already logged in with PIN, automatically use current user
        const completedBy = currentUser;
        
        // If it's "Other", prompt for the specific chore name and set up collaboration
        if (choreName === "Other") {
          const customChoreName = prompt("What chore did you complete? (e.g., 'Cleaned Bathroom', 'Organized Pantry'):");
          if (!customChoreName || customChoreName.trim() === "") {
            alert("Please enter a chore name.");
            return;
          }
          
          // Set up the collaboration modal for the custom chore
          setPendingChoreClaim({ choreName: customChoreName.trim(), completedBy, isOtherChore: true });
          setSelectedCollaborators([]);
          setShowCollaborationModal(true);
          return;
        }
        
        // Check for conflicts before proceeding
        if (checkForConflicts(choreName, 'complete', completedBy)) {
          alert(`⚠️ CONFLICT DETECTED!\n\nSomeone else already claimed they completed ${choreName}.\n\nThis conflict has been logged for admin review.`);
          return;
        }
        
        // Set up the collaboration modal
        setPendingChoreClaim({ choreName, completedBy });
        setSelectedCollaborators([]);
        setShowCollaborationModal(true);
      }

      function handleCompleteChore(choreName) {
        // Check if current user is paused
        if (paused[currentUser]) {
          alert(`❌ You are currently paused and cannot claim tasks. Please contact admin to unpause you.`);
          return;
        }
        
        // Since user is already logged in with PIN, automatically use current user
        const completedBy = currentUser;
        
        // Check for conflicts before proceeding
        if (checkForConflicts(choreName, 'complete', completedBy)) {
          alert(`⚠️ CONFLICT DETECTED!\n\nSomeone else already claimed they completed ${choreName}.\n\nThis conflict has been logged for admin review.`);
          return;
        }
        
        completeChore(choreName, { completedBy, advance: true });
      }

      function quickClaim(kind, name, action) {
        // Check if the person is paused
        if (paused[name]) {
          alert(`❌ ${name} is currently paused and cannot claim tasks. Please contact admin to unpause them.`);
          return;
        }
        
        if (!requirePinFor(name)) return;
        
        if (action === 'run') {
          if (checkForConflicts(kind, 'run', name)) {
            alert(`⚠️ CONFLICT DETECTED!\n\nSomeone else already claimed they ran the ${kind === '3pm' ? '3 PM' : 'Night'} load.\n\nThis conflict has been logged for admin review.`);
            return;
          }
          completeLoad(kind, { runBy: name, unloadBy: null, advance: true });
        } else if (action === 'unload') {
          // Check if there's already a history entry for this shift that we can update
          const existingEntry = history.find(h => h.kind === kind && h.runBy && !h.unloadBy);
          
          if (existingEntry) {
            // Update existing entry with unload
            setState((s) => {
              const updatedHistory = s.history.map(h => {
                if (h.id === existingEntry.id) {
                  // Calculate new credits
                  const currentPerson = kind === '3pm' ? activeQueue3pm[0] : activeQueueNight[0];
                  const runCredit = 0.5;
                  const unloadCredit = existingEntry.runBy === currentPerson ? 0.5 : 0.8; // Bonus if helper
                  
                  // Update credits
                  const c = { ...s.credits };
                  c[name] = (c[name] ?? 0) + unloadCredit;
                  
                  return {
                    ...h,
                    unloadBy: name,
                    unloadCredit,
                    isFavor: true
                  };
                }
                return h;
              });
              
              return { ...s, history: updatedHistory };
            });
          } else {
            // Create new entry if no existing run entry
            if (checkForConflicts(kind, 'unload', name)) {
              alert(`⚠️ CONFLICT DETECTED!\n\nSomeone else already claimed they unloaded the ${kind === '3pm' ? '3 PM' : 'Night'} load.\n\nThis conflict has been logged for admin review.`);
              return;
            }
            const runner = kind === '3pm' ? current3pm : currentNight || name;
            completeLoad(kind, { runBy: runner, unloadBy: name, advance: true });
          }
        } else if (action === 'both') {
          if (checkForConflicts(kind, 'run', name) || checkForConflicts(kind, 'unload', name)) {
            alert(`⚠️ CONFLICT DETECTED!\n\nSomeone else already claimed they did the ${kind === '3pm' ? '3 PM' : 'Night'} load.\n\nThis conflict has been logged for admin review.`);
            return;
          }
          completeLoad(kind, { runBy: name, unloadBy: name, advance: true });
        }
      }

      function quickClaimChore(choreName, name) {
        // Check if the person is paused
        if (paused[name]) {
          alert(`❌ ${name} is currently paused and cannot claim tasks. Please contact admin to unpause them.`);
          return;
        }
        
        if (!requirePinFor(name)) return;
        
        if (checkForConflicts(choreName, 'complete', name)) {
          alert(`⚠️ CONFLICT DETECTED!\n\nSomeone else already claimed they completed ${choreName}.\n\nThis conflict has been logged for admin review.`);
          return;
        }
        
        claimOptionalChore(choreName, name);
      }

      // Bathroom handoff functions
      function getBathroomForUser(user) {
        return Object.entries(bathrooms).find(([bathroomName, bathroom]) => 
          bathroom.pair.includes(user)
        );
      }

      function canSeeBathroom(user, bathroomName) {
        const bathroom = bathrooms[bathroomName];
        return bathroom && bathroom.pair.includes(user);
      }

      function handleBathroomClean(bathroomName) {
        // Check if current user is paused
        if (paused[currentUser]) {
          alert(`❌ You are currently paused and cannot claim tasks. Please contact admin to unpause you.`);
          return;
        }
        
        const bathroom = bathrooms[bathroomName];
        if (!bathroom) {
          console.error('Bathroom not found:', bathroomName);
          return;
        }

        // Check if current user is in the pair for this bathroom
        if (!bathroom.pair.includes(currentUser)) {
          alert("You can only clean bathrooms assigned to your pair.");
          return;
        }

        // Check if current user is currently responsible
        if (bathroom.currentResponsible !== currentUser) {
          alert(`You are not currently responsible for ${bathroomName}. ${bathroom.currentResponsible} is responsible.`);
          return;
        }

        // Hand off responsibility to the other person in the pair
        const otherPerson = bathroom.pair.find(person => person !== currentUser);
        

        
        setState((s) => {
          const updatedBathrooms = { ...s.bathrooms };
          updatedBathrooms[bathroomName] = {
            ...updatedBathrooms[bathroomName],
            currentResponsible: otherPerson,
            lastCleaned: new Date().toISOString(),
            lastCleanedBy: currentUser
          };

          // Add to history
          const entry = {
            id: Math.random().toString(36).slice(2),
            when: new Date().toISOString(),
            type: 'bathroom_clean',
            bathroomName,
            cleanedBy: currentUser,
            nextResponsible: otherPerson
          };

          const newState = { 
            ...s, 
            bathrooms: updatedBathrooms,
            history: [entry, ...s.history].slice(0, 200)
          };

          return newState;
        });

        alert(`✅ ${bathroomName} cleaned! Responsibility now passes to ${otherPerson}.`);
      }

      // Show login modal if not logged in
      if (showLoginModal) {
        return (
          <div className="min-h-screen bg-gray-50 flex items-center justify-center p-4">
            <div className="bg-white rounded-2xl shadow-lg p-8 max-w-md w-full">
              <h1 className="text-2xl font-bold text-center mb-6">Roommate Chores</h1>
              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium mb-2">Enter Your PIN</label>
                  <input
                    type="password"
                    className="w-full rounded-lg border px-4 py-3 text-center text-lg"
                    placeholder="Enter your 4-8 digit PIN"
                    value={loginPin}
                    onChange={(e) => setLoginPin(e.target.value)}
                    onKeyPress={(e) => e.key === 'Enter' && handleLogin()}
                    autoFocus
                  />
                </div>
                {loginError && (
                  <div className="text-red-600 text-sm text-center">{loginError}</div>
                )}
                <button
                  className="w-full bg-black text-white py-3 rounded-lg font-medium"
                  onClick={handleLogin}
                >
                  Login
                </button>
                <div className="text-center">
                  <div className="text-gray-400 text-sm mb-2">— or —</div>
                  <button
                    className="w-full bg-gray-200 text-gray-700 py-3 rounded-lg font-medium hover:bg-gray-300"
                    onClick={handleGuestMode}
                  >
                    Continue as Guest (View Only)
                  </button>
                </div>
                <div className="text-xs text-gray-500 text-center">
                  Enter your PIN to access your personalized dashboard, or continue as guest to view only
                </div>
              </div>
            </div>
          </div>
        );
      }

      return (
        <div className="min-h-screen bg-gray-50 text-gray-900 p-4 md:p-8">
          <div className="max-w-5xl mx-auto space-y-6">
            <header className="flex items-center justify-between">
              <div>
                <h1 className="text-2xl md:text-3xl font-bold">Roommate Chores • Rotation System</h1>
                <p className="text-sm text-gray-600 mt-1">
                  Welcome, <b>{currentUser}</b>! 
                  {isGuest && <span className="text-orange-600 font-medium"> (Guest Mode - View Only)</span>}
                  <button className="text-blue-600 underline ml-2" onClick={handleLogout}>Logout</button>
                </p>
                <p className="text-xs text-gray-500">
                  Today is: {getCurrentDateTime().dateString} • {getCurrentDateTime().greeting} • {getCurrentDateTime().timeString} CST
                </p>
                {!isGuest && (
                  <button 
                    className="text-xs text-blue-600 underline mt-1"
                    onClick={() => {
                      const newPin = prompt(`Enter new PIN for ${currentUser} (4-8 digits):`);
                      if (newPin && /^[0-9]{4,8}$/.test(newPin)) {
                        // Check if PIN is the same as current
                        if (newPin === pins[currentUser]) {
                          alert("New PIN cannot be the same as your current PIN. Please choose a different PIN.");
                          return;
                        }
                        
                        // Check if another roommate has this PIN
                        const existingUser = roommates.find(name => name !== currentUser && pins[name] === newPin);
                        if (existingUser) {
                          alert(`PIN ${newPin} is already in use. Please choose a different PIN.`);
                          return;
                        }
                        
                        const confirmPin = prompt(`Confirm new PIN for ${currentUser} (4-8 digits):`);
                        if (confirmPin === newPin) {
                          setState((s) => ({ 
                            ...s, 
                            pins: { ...s.pins, [currentUser]: newPin } 
                          }));
                          alert(`${currentUser}'s PIN has been updated to ${newPin}`);
                        } else if (confirmPin !== null) {
                          alert("PINs don't match. PIN change cancelled.");
                        }
                      } else if (newPin !== null) {
                        alert("PIN must be 4-8 digits.");
                      }
                    }}
                  >
                    Change My PIN
                  </button>
                )}
              </div>
              <Label>Chore Rotation • PINs enabled • Fair distribution</Label>
            </header>

            {/* Roommate Call-outs Section */}
            {(() => {
              const callouts = getRoommateCallouts();
              if (callouts.length === 0) return null;
              
              return (
                <div className="rounded-2xl shadow-sm border p-4 bg-red-50 border-red-200">
                  <div className="flex items-center gap-2 mb-3">
                    <span className="text-xl">🚨</span>
                    <h2 className="text-lg font-semibold text-red-800">Roommate Call-outs</h2>
                  </div>
                  <div className="space-y-2">
                    {callouts.map((callout, index) => (
                      <div key={index} className="flex items-center gap-3 p-3 bg-white rounded-lg border border-red-300">
                        <div className="flex-shrink-0">
                          {callout.type === 'missed_shift' ? (
                            <span className="text-orange-500 text-lg">⏰</span>
                          ) : (
                            <span className="text-red-500 text-lg">🧹</span>
                          )}
                        </div>
                        <div className="flex-1">
                          <div className="font-medium text-red-800">
                            {callout.roommate}
                          </div>
                          <div className="text-sm text-red-600">
                            {callout.reason}
                          </div>
                        </div>
                        <div className="flex-shrink-0">
                          {callout.type === 'missed_shift' && (
                            <span className="px-2 py-1 bg-orange-100 text-orange-800 text-xs rounded-full">
                              {callout.shift} Shift
                            </span>
                          )}
                          {callout.type === 'no_optional_chores' && (
                            <span className="px-2 py-1 bg-red-100 text-red-800 text-xs rounded-full">
                              No Optional Chores
                            </span>
                          )}
                        </div>
                      </div>
                    ))}
                  </div>
                  <div className="text-xs text-red-600 mt-2">
                    💡 These call-outs help keep everyone accountable and maintain fair chore distribution.
                  </div>
                </div>
              );
            })()}

            <Section title="House Rules (Quick Ref)">
              <ul className="list-disc pl-6 space-y-1 text-sm">
                <li>Everyone rinses their own dishes. Dishwasher-safe items go in immediately.</li>
                <li>Hand-wash lane: big pots/pans, knives, wooden tools, non-safe plastics.</li>
                <li>Rotation is by <b>load</b>. Flex Rule: you can run/unload for someone else; credits go to who actually did it.</li>
                <li>Night load must be <b>run & unloaded before bed</b> so mornings start empty.</li>
                <li>Don't run during Brunch Buffer (11:00 AM–2:00 PM). Aim for a 3:00 PM load, and a 9:00 PM–11:00 PM load.</li>
                <li><b>Optional Chores:</b> Extra tasks you can claim for points. No rotation - first come, first served!</li>
                <li><b>Collaboration:</b> When claiming optional chores, you can choose to work alone or with others. Points are shared evenly among collaborators.</li>
                <li><b>Own Mess:</b> If it's solely your own mess, you are very much responsible for cleaning it up yourself.</li>
                <li><b>PINs:</b> Each roommate sets a numeric PIN (4–8 digits). You must enter your PIN to claim "I ran" or "I unloaded".</li>
              </ul>
            </Section>

            <Section title="Roommates & Rotation">
              <div className="grid md:grid-cols-2 gap-4">
                <div className="space-y-3">
                  <div className="text-sm font-medium">Roommates</div>
                  <div className="text-lg font-semibold text-gray-700">{roommates.join(", ")}</div>
                  <div className="text-xs text-gray-500">Tip: Pause if someone is away. Queue advances automatically when current person completes a load.</div>
                  {!isGuest && (
                    <div className="mt-3 p-3 bg-gray-50 rounded-lg">
                      <div className="text-sm font-medium mb-2">Request Pause</div>
                      <div className="grid grid-cols-2 gap-2">
                        {roommates.map((name) => (
                          <button 
                            key={name}
                            className={`px-3 py-2 rounded-lg text-sm border ${name === currentUser ? (paused[name] ? 'bg-green-100 border-green-300 text-green-800' : 'bg-white border-gray-300 text-gray-700') : 'opacity-50 cursor-not-allowed bg-gray-100 border-gray-200 text-gray-600'}`}
                            onClick={() => name === currentUser && requestPause(name)}
                            disabled={name !== currentUser}
                          >
                            {name}: {name === currentUser ? (paused[name] ? 'Request Unpause' : 'Request Pause') : (paused[name] ? 'Paused' : 'Unpaused')}
                          </button>
                        ))}
                          </div>
                    </div>
                  )}
                  <div className="space-y-3">
                    <div>
                      <div className="text-sm font-medium mb-2">3 PM Queue (Forward)</div>
                      <div className="flex flex-wrap gap-2">
                        {activeQueue3pm.map((name, idx) => (
                          <div key={`3pm-${name}`} className={`px-3 py-1 rounded-full text-sm border shadow-sm ${idx===0?"bg-black text-white":"bg-white"}`}>
                            <div className="flex items-center gap-2">
                              <span>{idx+1}. {name}</span>
                        </div>
                      </div>
                    ))}
                  </div>
                      <div className="text-xs text-gray-500 mt-1">Full order: {activeQueue3pm.join(" → ")}</div>
                </div>
                    <div>
                      <div className="text-sm font-medium mb-2">Night Queue (Backward)</div>
                      <div className="flex flex-wrap gap-2">
                        {activeQueueNight.map((name, idx) => (
                          <div key={`night-${name}`} className={`px-3 py-1 rounded-full text-sm border shadow-sm ${idx===0?"bg-black text-white":"bg-white"}`}>
                            <div className="flex items-center gap-2">
                              <span>{idx+1}. {name}</span>
                        </div>
                      </div>
                    ))}
                  </div>
                      <div className="text-xs text-gray-500 mt-1">Full order: {activeQueueNight.join(" → ")}</div>
                </div>
              </div>
                    </div>
                                  {!isGuest && (
                    <div className="space-y-2">
                      <div className="text-sm font-medium mb-1">Quick Actions for {currentUser}</div>
                      <div className="rounded-xl border p-4 bg-white">
                        <div className="font-medium text-sm mb-3">Record your actions:</div>
                        <div className="grid grid-cols-3 gap-2">
                          <button 
                            className={`px-3 py-2 rounded-lg border ${paused[currentUser] ? 'bg-gray-100 text-gray-400 cursor-not-allowed' : 'bg-blue-50 hover:bg-blue-100'}`} 
                            onClick={() => !paused[currentUser] && quickClaim('3pm', currentUser, 'run')}
                            disabled={paused[currentUser]}
                          >
                            {paused[currentUser] ? 'PAUSED' : 'I ran 3 PM'}
                          </button>
                          <button 
                            className={`px-3 py-2 rounded-lg border ${paused[currentUser] ? 'bg-gray-100 text-gray-400 cursor-not-allowed' : 'bg-green-50 hover:bg-green-100'}`} 
                            onClick={() => !paused[currentUser] && quickClaim('3pm', currentUser, 'unload')}
                            disabled={paused[currentUser]}
                          >
                            {paused[currentUser] ? 'PAUSED' : 'I unloaded 3 PM'}
                          </button>
                          <button 
                            className={`px-3 py-2 rounded-lg border ${paused[currentUser] ? 'bg-gray-100 text-gray-400 cursor-not-allowed' : 'bg-purple-50 hover:bg-purple-100'}`} 
                            onClick={() => !paused[currentUser] && quickClaim('3pm', currentUser, 'both')}
                            disabled={paused[currentUser]}
                          >
                            {paused[currentUser] ? 'PAUSED' : 'BOTH 3PM'}
                          </button>
                          <button 
                            className={`px-3 py-2 rounded-lg border ${paused[currentUser] ? 'bg-gray-100 text-gray-400 cursor-not-allowed' : 'bg-blue-50 hover:bg-blue-100'}`} 
                            onClick={() => !paused[currentUser] && quickClaim('night', currentUser, 'run')}
                            disabled={paused[currentUser]}
                          >
                            {paused[currentUser] ? 'PAUSED' : 'I ran Night'}
                          </button>
                          <button 
                            className={`px-3 py-2 rounded-lg border ${paused[currentUser] ? 'bg-gray-100 text-gray-400 cursor-not-allowed' : 'bg-green-50 hover:bg-green-100'}`} 
                            onClick={() => !paused[currentUser] && quickClaim('night', currentUser, 'unload')}
                            disabled={paused[currentUser]}
                          >
                            {paused[currentUser] ? 'PAUSED' : 'I unloaded Night'}
                          </button>
                          <button 
                            className={`px-3 py-2 rounded-lg border ${paused[currentUser] ? 'bg-gray-100 text-gray-400 cursor-not-allowed' : 'bg-purple-50 hover:bg-purple-100'}`} 
                            onClick={() => !paused[currentUser] && quickClaim('night', currentUser, 'both')}
                            disabled={paused[currentUser]}
                          >
                            {paused[currentUser] ? 'PAUSED' : 'BOTH NIGHT'}
                          </button>
                  </div>
                      </div>
                    </div>
                  )}
              </div>
            </Section>



            <Section title="Run / Unload Loads">
              <div className="grid md:grid-cols-2 gap-4">
                <div className="rounded-2xl border p-4 space-y-3">
                  <div className="flex items-center justify-between"><h3 className="font-semibold">3 PM Load</h3><Label>Run after 2:00 PM</Label></div>
                  <p className="text-sm text-gray-600">Current runner: <b>{current3pm ?? "—"}</b></p>
                  <p className="text-xs text-gray-500">Full order: {activeQueue3pm.join(" → ")}</p>
                  <div className="flex gap-2">
                    <button 
                      className={`px-3 py-2 rounded-xl ${isGuest ? 'bg-gray-300 text-gray-500 cursor-not-allowed' : paused[currentUser] ? 'bg-gray-300 text-gray-500 cursor-not-allowed' : 'bg-black text-white hover:bg-gray-800'}`} 
                      onClick={() => !isGuest && !paused[currentUser] && handleComplete("3pm")}
                      disabled={isGuest || paused[currentUser]}
                    >
                      {isGuest ? 'Record 3 PM (Guest Mode - View Only)' : paused[currentUser] ? 'Record 3 PM (PAUSED)' : 'Record 3 PM (I did both)'}
                    </button>
                  </div>
                  <p className="text-xs text-gray-500">Flex Rule: If you filled it or someone texted they can't make it, you may run/unload on their behalf. Credits split to the actual people (PINs required).</p>
                </div>
                <div className="rounded-2xl border p-4 space-y-3">
                  <div className="flex items-center justify-between"><h3 className="font-semibold">Night Load</h3><Label>9:00 PM–11:00 PM • Unload before bed</Label></div>
                  <p className="text-sm text-gray-600">Current runner: <b>{currentNight ?? "—"}</b></p>
                  <p className="text-xs text-gray-500">Full order: {activeQueueNight.join(" → ")}</p>
                  <div className="flex gap-2">
                    <button 
                      className={`px-3 py-2 rounded-xl ${isGuest ? 'bg-gray-300 text-gray-500 cursor-not-allowed' : paused[currentUser] ? 'bg-gray-300 text-gray-500 cursor-not-allowed' : 'bg-black text-white hover:bg-gray-800'}`} 
                      onClick={() => !isGuest && !paused[currentUser] && handleComplete("night")}
                      disabled={isGuest || paused[currentUser]}
                    >
                      {isGuest ? 'Record Night (Guest Mode - View Only)' : paused[currentUser] ? 'Record Night (PAUSED)' : 'Record Night (I did both)'}
                    </button>
                  </div>
                </div>
              </div>
            </Section>

            <Section title="Optional Chores (Extra Points)">
              <div className="space-y-4">
                <div className="text-sm text-gray-600 mb-3">
                  <p><b>Note:</b> If it's solely your own mess, you are very much responsible for cleaning it up yourself.</p>
                  <p>These are extra tasks you can claim for points. No rotation - first come, first served!</p>
                  </div>
                {!isGuest && (
                  <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3">
                    {Object.keys(optionalChores).map((choreName) => (
                      <button 
                        key={choreName}
                        className={`p-3 rounded-lg border text-left ${paused[currentUser] ? 'bg-gray-100 text-gray-400 cursor-not-allowed' : 'bg-white hover:bg-gray-50'}`}
                        onClick={() => !paused[currentUser] && handleClaimChore(choreName)}
                        disabled={paused[currentUser]}
                      >
                        <div className="font-medium text-sm">{choreName}</div>
                        <div className="text-xs text-gray-500 mt-1">{optionalChores[choreName].description}</div>
                        <div className="text-xs font-semibold text-blue-600 mt-1">
                          {paused[currentUser] ? 'PAUSED' : `+${optionalChores[choreName].points} points`}
                        </div>
                      </button>
                    ))}
                  </div>
                )}
                {isGuest && (
                  <div className="text-center text-gray-500 py-8">
                    <p>Guest Mode - View Only</p>
                    <p className="text-sm mt-2">Log in to claim optional chores for points</p>
                  </div>
                )}
              </div>
            </Section>

            <Section title="Bathroom Handoff System">
              <div className="space-y-4">
                <div className="text-sm text-gray-600 mb-3">
                  <p><b>How it works:</b> Each pair is responsible for one bathroom. When you finish cleaning, responsibility automatically passes to your partner.</p>
                  <p><b>Pairs:</b> (Kavya, Avani) → Bathroom 1 • (Himani, Khushi) → Bathroom 2</p>
                </div>
                
                <div className="grid md:grid-cols-2 gap-4">
                  {Object.entries(bathrooms).map(([bathroomName, bathroom]) => {
                    const canSee = !isGuest && canSeeBathroom(currentUser, bathroomName);
                    const isResponsible = bathroom.currentResponsible === currentUser;
                    const lastCleanedDate = bathroom.lastCleaned ? new Date(bathroom.lastCleaned) : null;
                    

                    
                    return (
                      <div key={bathroomName} className={`rounded-xl border p-4 ${canSee ? 'bg-white' : 'bg-gray-100'}`}>
                        <div className="flex items-center justify-between mb-3">
                          <h3 className="font-semibold">{bathroomName}</h3>
                          <div className="text-xs text-gray-500">
                            {bathroom.pair.join(" & ")}
                          </div>
                        </div>
                        
                        {canSee ? (
                          <div className="space-y-3">
                            <div className="flex items-center justify-between">
                              <span className="text-sm">Currently responsible:</span>
                              <span className={`font-medium ${isResponsible ? 'text-green-600' : 'text-gray-700'}`}>
                                {bathroom.currentResponsible}
                                {isResponsible && <span className="ml-1">(You!)</span>}
                              </span>
                            </div>
                            
                            {lastCleanedDate && (
                              <div className="text-xs text-gray-600">
                                Last cleaned: {lastCleanedDate.toLocaleDateString()} by {bathroom.lastCleanedBy}
                              </div>
                            )}
                            
                            {isResponsible && !isGuest ? (
                              <button
                                className={`w-full px-4 py-2 rounded-lg font-medium ${paused[currentUser] ? 'bg-gray-400 text-gray-200 cursor-not-allowed' : 'bg-green-600 text-white hover:bg-green-700'}`}
                                onClick={() => !paused[currentUser] && handleBathroomClean(bathroomName)}
                                disabled={paused[currentUser]}
                              >
                                {paused[currentUser] ? '⏸️ PAUSED - Cannot Clean' : `✅ I Finished Cleaning ${bathroomName}`}
                              </button>
                            ) : (
                              <div className="text-center py-2 text-gray-500 text-sm">
                                {isGuest ? 'Guest Mode - View Only' : `${bathroom.currentResponsible} is responsible`}
                              </div>
                            )}
                          </div>
                        ) : (
                          <div className="text-center py-4 text-gray-500">
                            <p>This bathroom is managed by</p>
                            <p className="font-medium">{bathroom.pair.join(" & ")}</p>
                          </div>
                        )}
                      </div>
                    );
                  })}
                </div>
                
                {!isGuest && (
                  <div className="text-xs text-gray-500 mt-3 p-3 bg-gray-50 rounded-lg">
                    <p><b>💡 Tip:</b> Only you and your partner can see your assigned bathroom. When you finish cleaning, click the button to hand off responsibility!</p>
                  </div>
                )}
              </div>
            </Section>

            <Section title="Credits & Balancing" extra={
              currentUser === "Himani" && !isGuest ? (
                <div className="flex gap-2">
                  <button className="text-sm underline text-red-600" onClick={() => setShowAdminPanel(true)}>Admin Panel</button>
                </div>
              ) : null
            }>
              <div className="grid sm:grid-cols-2 md:grid-cols-4 gap-3">
                {(() => {
                  // Create array of roommates with points and sort by points
                  const roommatesWithPoints = roommates
                    .map((n) => ({ name: n, points: credits[n] ?? 0 }))
                    .sort((a, b) => b.points - a.points);
                  
                  // Calculate actual places (handling ties)
                  const calculatePlaces = (roommates) => {
                    const places = [];
                    let currentPlace = 1;
                    let currentPoints = null;
                    
                    roommates.forEach((roommate, index) => {
                      if (roommate.points !== currentPoints) {
                        currentPlace = index + 1;
                        currentPoints = roommate.points;
                      }
                      places.push(currentPlace);
                    });
                    
                    return places;
                  };
                  
                  const places = calculatePlaces(roommatesWithPoints);
                  
                  return roommatesWithPoints.map((roommate, index) => {
                    const place = places[index];
                    const getPlaceStyle = () => {
                      switch (place) {
                        case 1:
                          return 'bg-yellow-50 border-yellow-200 shadow-sm';
                        case 2:
                          return 'bg-gray-50 border-gray-200 shadow-sm';
                        case 3:
                          return 'bg-orange-50 border-orange-200 shadow-sm';
                        case 4:
                          return 'bg-red-50 border-red-200 shadow-sm';
                        default:
                          return 'bg-white border-gray-200';
                      }
                    };
                    const getPlaceIcon = () => {
                      switch (place) {
                        case 1:
                          return '🥇';
                        case 2:
                          return '🥈';
                        case 3:
                          return '🥉';
                        case 4:
                          return '🏃';
                        default:
                          return '';
                      }
                    };
                    const getPlaceText = () => {
                      // Check if there are ties for this place
                      const peopleInThisPlace = places.filter(p => p === place).length;
                      const placeText = (() => {
                        switch (place) {
                          case 1:
                            return '1st Place';
                          case 2:
                            return '2nd Place';
                          case 3:
                            return '3rd Place';
                          case 4:
                            return '4th Place';
                          default:
                            return `${place}th Place`;
                        }
                      })();
                      
                      return peopleInThisPlace > 1 ? `${placeText} (Tied)` : placeText;
                    };
                    
                    return (
                      <div key={roommate.name} className={`rounded-xl border p-3 ${getPlaceStyle()}`}>
                        <div className="flex items-center justify-between mb-1">
                          <div className="text-sm font-medium">{roommate.name}</div>
                          <div className="text-lg">{getPlaceIcon()}</div>
                        </div>
                        <div className="text-2xl font-bold">{roommate.points.toFixed(1)}</div>
                        <div className="text-xs text-gray-500">{getPlaceText()}</div>
                        <div className="text-xs text-gray-400 mt-1">Target: keep everyone within ±2 over a month.</div>
                      </div>
                    );
                  });
                })()}
              </div>
            </Section>

            <Section title="History (latest 20)">
              <div className="overflow-x-auto">
                <table className="w-full text-sm">
                  <thead>
                    <tr className="text-left border-b">
                      <th className="py-2 pr-2">When</th>
                      <th className="py-2 pr-2">Task</th>
                      <th className="py-2 pr-2">Ran By</th>
                      <th className="py-2 pr-2">Unloaded By</th>
                      <th className="py-2 pr-2">Credits</th>
                    </tr>
                  </thead>
                  <tbody>
                    {history.filter(h => h.type !== 'bathroom_clean' && !h.bathroomName && !h.cleanedBy).slice(0,20).map((h) => (
                      <tr key={h.id} className="border-b last:border-0">
                        <td className="py-2 pr-2 whitespace-nowrap">
                          {(() => {
                            const date = new Date(h.when);
                            const cstDate = new Date(date.toLocaleString("en-US", {timeZone: "America/Chicago"}));
                            const today = new Date();
                            const cstToday = new Date(today.toLocaleString("en-US", {timeZone: "America/Chicago"}));
                            
                            // Check if it's today
                            const isToday = cstDate.toDateString() === cstToday.toDateString();
                            
                            const timeString = cstDate.toLocaleTimeString("en-US", {
                              timeZone: "America/Chicago",
                              hour: "numeric",
                              minute: "2-digit",
                              hour12: true
                            });
                            
                            if (isToday) {
                              return `Today at ${timeString}`;
                            } else {
                              const dateString = cstDate.toLocaleDateString("en-US", {
                                timeZone: "America/Chicago",
                                month: "short",
                                day: "numeric",
                                hour: "numeric",
                                minute: "2-digit",
                                hour12: true
                              });
                              return dateString;
                            }
                          })()}
                        </td>
                        <td className="py-2 pr-2">
                          {h.kind ? (
                            h.kind === '3pm' ? 
                              (h.runBy && h.unloadBy ? '3 PM Dishwasher' : 
                               h.runBy ? '3 PM Dishwasher Started' : 
                               h.unloadBy ? '3 PM Dishwasher Unloaded' : '3 PM Dishwasher') :
                            (h.runBy && h.unloadBy ? 'Night Dishwasher' : 
                             h.runBy ? 'Night Dishwasher Started' : 
                             h.unloadBy ? 'Night Dishwasher Unloaded' : 'Night Dishwasher')
                          ) : h.choreName}
                        </td>
                        <td className="py-2 pr-2">
                          {h.runBy || (h.completedBy ? h.completedBy : '')}
                        </td>
                        <td className="py-2 pr-2">
                          {h.unloadBy}
                        </td>
                        <td className="py-2 pr-2">
                          {h.kind ? (
                            <>
                              +{h.runCredit}+{h.unloadCredit}
                              {h.isFavor && <span className="text-xs text-blue-600 ml-1">(favor)</span>}
                            </>
                          ) : (
                            <>
                              +{h.pointsPerPerson || h.points}
                              {h.collaborators && h.collaborators.length > 0 && (
                                <span className="text-xs text-green-600 ml-1">(shared with {h.collaborators.join(', ')})</span>
                              )}
                              {h.isFavor && <span className="text-xs text-blue-600 ml-1">(favor)</span>}
                            </>
                          )}
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </Section>

            <footer className="text-xs text-gray-500 text-center pb-6">
              <div className="mb-2">Tip: You can host this file as-is on Netlify/Vercel/GitHub Pages. Data (including PINs) is saved <b>locally on this device</b>.</div>
              <div className="text-red-600 font-semibold">⚠️ ADMIN ACCESS: Only Himani can pause roommates, set PINs, or reset data. Others can only record their own chore completions.</div>

            </footer>

            {showCollaborationModal && (
              <div style={{
                position: 'fixed',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                backgroundColor: 'rgba(0,0,0,0.5)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                zIndex: 9999
              }}>
                <div className="bg-white rounded-xl p-6 max-w-md w-full mx-4">
                  <h3 className="text-lg font-semibold mb-4">
                    {pendingChoreClaim?.completedBy === currentUser ? 'Collaboration Selection' : `Admin: ${pendingChoreClaim?.completedBy}'s Collaboration`}
                  </h3>
                  <div className="space-y-4">
                    <div className="text-sm text-gray-600">
                      <p><b>Chore:</b> {pendingChoreClaim?.choreName}</p>
                      <p><b>Total Points:</b> {optionalChores[pendingChoreClaim?.choreName]?.points || 1.0}</p>
                      <p className="mt-2">
                        {pendingChoreClaim?.completedBy === currentUser 
                          ? 'Select who you worked with on this chore:'
                          : `Select who ${pendingChoreClaim?.completedBy} worked with on this chore:`
                        }
                      </p>
          </div>
                    
                    <div className="space-y-2">
                      <div className="flex gap-2 mb-2">
                        <button
                          className="px-3 py-1 text-xs bg-green-100 text-green-700 rounded border hover:bg-green-200"
                          onClick={() => {
                            const availableRoommates = roommates.filter(name => name !== pendingChoreClaim?.completedBy);
                            setSelectedCollaborators(availableRoommates);
                          }}
                        >
                          Select All
                        </button>
                        <button
                          className="px-3 py-1 text-xs bg-red-100 text-red-700 rounded border hover:bg-red-200"
                          onClick={() => setSelectedCollaborators([])}
                        >
                          Clear All
                        </button>
        </div>
                      {roommates.filter(name => name !== pendingChoreClaim?.completedBy).map((name) => (
                        <button
                          key={name}
                          className={`w-full p-3 rounded-lg border text-left transition-colors ${
                            selectedCollaborators.includes(name)
                              ? 'bg-blue-100 border-blue-300 text-blue-800'
                              : 'bg-white border-gray-300 hover:bg-gray-50'
                          }`}
                          onClick={() => {
                            setSelectedCollaborators(prev => 
                              prev.includes(name) 
                                ? prev.filter(n => n !== name)
                                : [...prev, name]
                            );
                          }}
                        >
                          <div className="flex items-center justify-between">
                            <span className="font-medium">{name}</span>
                            {selectedCollaborators.includes(name) && (
                              <span className="text-blue-600">✓</span>
                            )}
                          </div>
                        </button>
                      ))}
                    </div>
                    
                    <div className="text-sm text-gray-600 p-3 bg-gray-50 rounded-lg">
                      <p><b>Points Distribution:</b></p>
                      <p>{pendingChoreClaim?.completedBy === currentUser ? 'You' : pendingChoreClaim?.completedBy}: {pendingChoreClaim?.completedBy}</p>
                      {selectedCollaborators.length > 0 && (
                        <p>Collaborators: {selectedCollaborators.join(', ')}</p>
                      )}
                      <p className="mt-1">
                        <b>Points per person:</b> {
                          selectedCollaborators.length > 0 
                            ? ((optionalChores[pendingChoreClaim?.choreName]?.points || 1.0) / (selectedCollaborators.length + 1)).toFixed(2)
                            : (optionalChores[pendingChoreClaim?.choreName]?.points || 1.0)
                        }
                      </p>
                    </div>
                    
                    <div className="flex gap-3">
                      <button
                        className="flex-1 px-4 py-2 bg-gray-300 rounded-lg hover:bg-gray-400"
                        onClick={() => {
                          setShowCollaborationModal(false);
                          setPendingChoreClaim(null);
                          setSelectedCollaborators([]);
                        }}
                      >
                        Cancel
                      </button>
                      <button
                        className="flex-1 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                        onClick={() => {
                          if (pendingChoreClaim) {
                            if (pendingChoreClaim.isOtherChore) {
                              // For "Other" chores, send to admin for approval
                              const otherChore = {
                                id: Math.random().toString(36).slice(2),
                                choreName: pendingChoreClaim.choreName,
                                completedBy: pendingChoreClaim.completedBy,
                                collaborators: selectedCollaborators,
                                timestamp: new Date().toISOString(),
                                status: "pending"
                              };
                              
                              setPendingOtherChores(prev => [...prev, otherChore]);
                              alert(`"${pendingChoreClaim.choreName}" has been sent to admin for approval with ${selectedCollaborators.length + 1} people. You'll get points once approved.`);
                            } else {
                              // For regular chores, claim immediately
                              claimOptionalChore(pendingChoreClaim.choreName, pendingChoreClaim.completedBy, selectedCollaborators);
                            }
                          }
                          setShowCollaborationModal(false);
                          setPendingChoreClaim(null);
                          setSelectedCollaborators([]);
                        }}
                      >
                        {pendingChoreClaim?.isOtherChore ? 'Send to Admin' : `Confirm (${selectedCollaborators.length + 1} people)`}
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            )}

            {showAdminPanel && (
              <div style={{
                position: 'fixed',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                backgroundColor: 'rgba(0,0,0,0.5)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                zIndex: 9999
              }}>
                <div className="bg-white rounded-xl p-6 max-w-4xl w-full mx-4 max-h-[90vh] overflow-y-auto">
                  <h3 className="text-lg font-semibold mb-4">Admin Panel</h3>
                  <div className="space-y-4">
                    {pauseRequests.filter(r => r.status === "pending").length > 0 && (
                      <div className="space-y-3">
                        <h4 className="font-medium text-sm text-blue-600">⏸️ Pause Requests</h4>
                        {pauseRequests.filter(r => r.status === "pending").map((request) => (
                          <div key={request.id} className="border border-blue-200 rounded-lg p-3 bg-blue-50">
                            <div className="text-sm font-medium mb-2">
                              {request.name} wants to {request.action}
                            </div>
                            <div className="text-xs text-gray-600 mb-2">
                              {(() => {
                                const date = new Date(request.timestamp);
                                const cstDate = new Date(date.toLocaleString("en-US", {timeZone: "America/Chicago"}));
                                return cstDate.toLocaleString("en-US", {
                                  timeZone: "America/Chicago",
                                  month: "short",
                                  day: "numeric",
                                  hour: "numeric",
                                  minute: "2-digit",
                                  hour12: true
                                });
                              })()}
                            </div>
                            <div className="flex gap-2">
                              <button 
                                className="px-2 py-1 bg-green-600 text-white rounded text-[10px]"
                                onClick={() => approvePauseRequest(request.id)}
                              >
                                Approve
                              </button>
                              <button 
                                className="px-2 py-1 bg-red-600 text-white rounded text-[10px]"
                                onClick={() => rejectPauseRequest(request.id)}
                              >
                                Reject
                              </button>
                            </div>
                          </div>
                        ))}
                      </div>
                    )}
                    {pendingOtherChores.filter(c => c.status === "pending").length > 0 && (
                      <div className="space-y-3">
                        <h4 className="font-medium text-sm text-green-600">📝 Other Chores Pending Approval</h4>
                        {pendingOtherChores.filter(c => c.status === "pending").map((chore) => (
                          <div key={chore.id} className="border border-green-200 rounded-lg p-3 bg-green-50">
                            <div className="text-sm font-medium mb-2">
                              {chore.completedBy} completed: "{chore.choreName}"
                              {chore.collaborators && chore.collaborators.length > 0 && (
                                <div className="text-xs text-gray-600 mt-1">
                                  Collaborators: {chore.collaborators.join(', ')}
                                </div>
                              )}
                            </div>
                            <div className="text-xs text-gray-600 mb-2">
                              {(() => {
                                const date = new Date(chore.timestamp);
                                const cstDate = new Date(date.toLocaleString("en-US", {timeZone: "America/Chicago"}));
                                return cstDate.toLocaleString("en-US", {
                                  timeZone: "America/Chicago",
                                  month: "short",
                                  day: "numeric",
                                  hour: "numeric",
                                  minute: "2-digit",
                                  hour12: true
                                });
                              })()}
                            </div>
                            <div className="flex gap-2">
                              <button 
                                className="px-2 py-1 bg-green-600 text-white rounded text-[10px]"
                                onClick={() => approveOtherChore(chore.id)}
                              >
                                Approve
                              </button>
                              <button 
                                className="px-2 py-1 bg-red-600 text-white rounded text-[10px]"
                                onClick={() => rejectOtherChore(chore.id)}
                              >
                                Reject
                              </button>
                            </div>
                          </div>
                        ))}
                      </div>
                    )}
                    {conflicts.length > 0 && (
                      <div className="space-y-3">
                        <h4 className="font-medium text-sm text-red-600">⚠️ Conflicts to Resolve</h4>
                        {conflicts.filter(c => !c.resolved).map((conflict) => (
                          <div key={conflict.id} className="border border-red-200 rounded-lg p-3 bg-red-50">
                            <div className="text-sm font-medium mb-2">
                              {conflict.kindOrChore === '3pm' ? '3 PM' : 
                               conflict.kindOrChore === 'night' ? 'Night' : 
                               conflict.kindOrChore} - {conflict.action}
                            </div>
                            <div className="text-xs text-gray-600 mb-2">
                              {conflict.existingClaim} claimed first, {conflict.newClaim} claimed second
                            </div>
                            <div className="text-xs text-gray-500 mb-2">
                              {(() => {
                                const date = new Date(conflict.timestamp);
                                const cstDate = new Date(date.toLocaleString("en-US", {timeZone: "America/Chicago"}));
                                return cstDate.toLocaleString("en-US", {
                                  timeZone: "America/Chicago",
                                  month: "short",
                                  day: "numeric",
                                  hour: "numeric",
                                  minute: "2-digit",
                                  hour12: true
                                });
                              })()}
                            </div>
                            <div className="flex gap-2">
                              <button 
                                className="px-2 py-1 bg-green-600 text-white rounded text-[10px]"
                                onClick={() => {
                                  // Give credit to the new claim, remove from existing
                                  setState((s) => {
                                    const c = { ...s.credits };
                                    const existingPerson = conflict.existingClaim;
                                    const newPerson = conflict.newClaim;
                                    
                                    // Determine points to add/remove based on conflict type
                                    let points = 1.0;
                                    if (conflict.kindOrChore === '3pm' || conflict.kindOrChore === 'night') {
                                      points = 0.5; // Dishwasher tasks are 0.5 each
                                      // Remove credit from existing claim
                                      c[existingPerson] = Math.max(0, (c[existingPerson] ?? 0) - points);
                                      // Add credit to new claim
                                      c[newPerson] = (c[newPerson] ?? 0) + points;
                                    } else {
                                      // Optional chore - need to handle collaborations
                                      const chore = optionalChores[conflict.kindOrChore];
                                      const totalPoints = chore ? chore.points : 1.0;
                                      
                                      // Find the existing entry to see if it was a collaboration
                                      const existingEntry = history.find(h => 
                                        h.choreName === conflict.kindOrChore && 
                                        h.completedBy === existingPerson &&
                                        new Date(h.when) > timeAgo
                                      );
                                      
                                      if (existingEntry && existingEntry.collaborators && existingEntry.collaborators.length > 0) {
                                        // Remove points from all collaborators
                                        const pointsPerPerson = existingEntry.pointsPerPerson || totalPoints / (existingEntry.collaborators.length + 1);
                                        c[existingPerson] = Math.max(0, (c[existingPerson] ?? 0) - pointsPerPerson);
                                        existingEntry.collaborators.forEach(collaborator => {
                                          c[collaborator] = Math.max(0, (c[collaborator] ?? 0) - pointsPerPerson);
                                        });
                                      } else {
                                        // Solo work - remove full points
                                        c[existingPerson] = Math.max(0, (c[existingPerson] ?? 0) - totalPoints);
                                      }
                                      
                                      // Add full points to new claim (they can choose collaboration later)
                                      c[newPerson] = (c[newPerson] ?? 0) + totalPoints;
                                    }
                                    
                                    return { ...s, credits: c };
                                  });
                                  
                                  // Mark conflict as resolved
                                  setConflicts(prev => prev.map(c => 
                                    c.id === conflict.id ? { ...c, resolved: true } : c
                                  ));
                                  
                                  alert(`Resolved: ${conflict.newClaim} gets credit for ${conflict.action}`);
                                }}
                              >
                                Give to {conflict.newClaim}
                              </button>
                              <button 
                                className="px-2 py-1 bg-blue-600 text-white rounded text-[10px]"
                                onClick={() => {
                                  // Mark conflict as resolved (keep existing claim)
                                  setConflicts(prev => prev.map(c => 
                                    c.id === conflict.id ? { ...c, resolved: true } : c
                                  ));
                                  alert(`Resolved: ${conflict.existingClaim} keeps credit for ${conflict.action}`);
                                }}
                              >
                                Keep with {conflict.existingClaim}
                              </button>
                            </div>
                          </div>
                        ))}
                      </div>
                    )}
                    <div className="space-y-3">
                      <h4 className="font-medium text-sm">Manual Pause Controls</h4>
                      <div className="grid grid-cols-2 gap-2">
                        {roommates.map((name) => (
                          <div key={name} className="flex items-center gap-2">
                            <span className="text-xs w-12">{name}:</span>
                            <button 
                              className={`px-2 py-1 rounded text-[10px] ${paused[name] ? 'bg-green-600 text-white' : 'bg-gray-300 text-gray-700'}`}
                              onClick={() => {
                                setState((s) => {
                                  const p = { ...s.paused, [name]: !s.paused[name] };
                                  return { ...s, paused: p };
                                });
                              }}
                            >
                              {paused[name] ? 'Unpause' : 'Pause'}
                            </button>
                          </div>
                        ))}
                      </div>
                    </div>
                    <div className="space-y-3">
                      <h4 className="font-medium text-sm">Admin Actions (Enter for Others)</h4>
                      <div className="grid grid-cols-2 gap-3">
                        {roommates.map((name) => (
                          <div key={name} className="border rounded-lg p-2">
                            <div className="text-xs font-medium mb-2">{name}</div>
                            <div className="grid grid-cols-3 gap-1 text-[10px]">
                              <button 
                                className="px-1 py-1 bg-blue-100 rounded"
                                onClick={() => {
                                  if (checkForConflicts('3pm', 'run', name)) {
                                    alert(`⚠️ CONFLICT DETECTED!\n\nSomeone else already claimed they ran the 3 PM load.\n\nThis conflict has been logged for admin review.`);
                                    return;
                                  }
                                  completeLoad('3pm', { runBy: name, unloadBy: name, advance: true });
                                }}
                              >
                                3PM Run
                              </button>
                              <button 
                                className="px-1 py-1 bg-green-100 rounded"
                                onClick={() => {
                                  if (checkForConflicts('3pm', 'unload', name)) {
                                    alert(`⚠️ CONFLICT DETECTED!\n\nSomeone else already claimed they unloaded the 3 PM load.\n\nThis conflict has been logged for admin review.`);
                                    return;
                                  }
                                  const runner = current3pm || name;
                                  completeLoad('3pm', { runBy: runner, unloadBy: name, advance: true });
                                }}
                              >
                                3PM Unload
                              </button>
                              <button 
                                className="px-1 py-1 bg-purple-100 rounded"
                                onClick={() => {
                                  if (checkForConflicts('3pm', 'run', name) || checkForConflicts('3pm', 'unload', name)) {
                                    alert(`⚠️ CONFLICT DETECTED!\n\nSomeone else already claimed they did the 3 PM load.\n\nThis conflict has been logged for admin review.`);
                                    return;
                                  }
                                  completeLoad('3pm', { runBy: name, unloadBy: name, advance: true });
                                }}
                              >
                                3PM Both
                              </button>
                              <button 
                                className="px-1 py-1 bg-blue-100 rounded"
                                onClick={() => {
                                  if (checkForConflicts('night', 'run', name)) {
                                    alert(`⚠️ CONFLICT DETECTED!\n\nSomeone else already claimed they ran the Night load.\n\nThis conflict has been logged for admin review.`);
                                    return;
                                  }
                                  completeLoad('night', { runBy: name, unloadBy: name, advance: true });
                                }}
                              >
                                Night Run
                              </button>
                              <button 
                                className="px-1 py-1 bg-green-100 rounded"
                                onClick={() => {
                                  if (checkForConflicts('night', 'unload', name)) {
                                    alert(`⚠️ CONFLICT DETECTED!\n\nSomeone else already claimed they unloaded the Night load.\n\nThis conflict has been logged for admin review.`);
                                    return;
                                  }
                                  const runner = currentNight || name;
                                  completeLoad('night', { runBy: runner, unloadBy: name, advance: true });
                                }}
                              >
                                Night Unload
                              </button>
                              <button 
                                className="px-1 py-1 bg-purple-100 rounded"
                                onClick={() => {
                                  if (checkForConflicts('night', 'run', name) || checkForConflicts('night', 'unload', name)) {
                                    alert(`⚠️ CONFLICT DETECTED!\n\nSomeone else already claimed they did the Night load.\n\nThis conflict has been logged for admin review.`);
                                    return;
                                  }
                                  completeLoad('night', { runBy: name, unloadBy: name, advance: true });
                                }}
                              >
                                Night Both
                              </button>
                            </div>
                          </div>
                        ))}
                      </div>
                    </div>
                    <div className="space-y-3">
                      <h4 className="font-medium text-sm">Optional Chores (Enter for Others)</h4>
                      <div className="grid grid-cols-2 gap-3">
                        {roommates.map((name) => (
                          <div key={name} className="border rounded-lg p-2">
                            <div className="text-xs font-medium mb-2">{name}</div>
                            <div className="grid grid-cols-2 gap-1 text-[10px]">
                              {Object.keys(optionalChores).map((choreName) => (
                                <button 
                                  key={choreName}
                                  className="px-1 py-1 bg-blue-100 rounded"
                                  onClick={() => {
                                    // If it's "Other", prompt for the specific chore name
                                    let finalChoreName = choreName;
                                    if (choreName === "Other") {
                                      const customChoreName = prompt(`What chore did ${name} complete? (e.g., 'Cleaned Bathroom', 'Organized Pantry'):`);
                                      if (!customChoreName || customChoreName.trim() === "") {
                                        alert("Please enter a chore name.");
                                        return;
                                      }
                                      finalChoreName = customChoreName.trim();
                                    }
                                    
                                    if (checkForConflicts(finalChoreName, 'complete', name)) {
                                      alert(`⚠️ CONFLICT DETECTED!\n\nSomeone else already claimed they completed ${finalChoreName}.\n\nThis conflict has been logged for admin review.`);
                                      return;
                                    }
                                    
                                    // Set up the collaboration modal for admin
                                    setPendingChoreClaim({ choreName: finalChoreName, completedBy: name });
                                    setSelectedCollaborators([]);
                                    setShowCollaborationModal(true);
                                  }}
                                >
                                  {choreName}
                                </button>
                              ))}
                            </div>
                          </div>
                        ))}
                      </div>
                    </div>
                    <div className="space-y-3">
                      <h4 className="font-medium text-sm">Bathroom Management</h4>
                      <div className="grid grid-cols-2 gap-3">
                        {Object.entries(bathrooms).map(([bathroomName, bathroom]) => (
                          <div key={bathroomName} className="border rounded-lg p-2">
                            <div className="text-xs font-medium mb-2">{bathroomName}</div>
                            <div className="text-xs text-gray-600 mb-2">
                              Pair: {bathroom.pair.join(" & ")}
                            </div>
                            <div className="text-xs text-gray-600 mb-2">
                              Current: {bathroom.currentResponsible}
                            </div>
                            <div className="grid grid-cols-2 gap-1 text-[10px]">
                              {bathroom.pair.map((person) => (
                                <button 
                                  key={person}
                                  className={`px-1 py-1 rounded ${bathroom.currentResponsible === person ? 'bg-green-100 text-green-700' : 'bg-gray-100 text-gray-700'}`}
                                  onClick={() => {
                                    setState((s) => {
                                      const updatedBathrooms = { ...s.bathrooms };
                                      updatedBathrooms[bathroomName] = {
                                        ...updatedBathrooms[bathroomName],
                                        currentResponsible: person
                                      };
                                      return { ...s, bathrooms: updatedBathrooms };
                                    });
                                  }}
                                >
                                  Set {person}
                                </button>
                              ))}
                            </div>
                            <div className="mt-2">
                              <button 
                                className="w-full px-1 py-1 bg-purple-100 text-purple-700 rounded text-[10px]"
                                onClick={() => {
                                  const newPerson = prompt(`Enter who cleaned ${bathroomName}:`);
                                  if (newPerson && bathroom.pair.includes(newPerson)) {
                                    const otherPerson = bathroom.pair.find(p => p !== newPerson);
                                    setState((s) => {
                                      const updatedBathrooms = { ...s.bathrooms };
                                      updatedBathrooms[bathroomName] = {
                                        ...updatedBathrooms[bathroomName],
                                        currentResponsible: otherPerson,
                                        lastCleaned: new Date().toISOString(),
                                        lastCleanedBy: newPerson
                                      };

                                      // Add to history
                                      const entry = {
                                        id: Math.random().toString(36).slice(2),
                                        when: new Date().toISOString(),
                                        type: 'bathroom_clean',
                                        bathroomName,
                                        cleanedBy: newPerson,
                                        nextResponsible: otherPerson
                                      };

                                      return { 
                                        ...s, 
                                        bathrooms: updatedBathrooms,
                                        history: [entry, ...s.history].slice(0, 200)
                                      };
                                    });
                                    alert(`${bathroomName} cleaned by ${newPerson}, responsibility now with ${otherPerson}`);
                                  }
                                }}
                              >
                                Record Clean
                              </button>

                            </div>
                          </div>
                        ))}
                      </div>
                    </div>
                    <div className="space-y-3">
                      <h4 className="font-medium text-sm">PIN Management</h4>
                      {roommates.map((name) => (
                        <div key={name} className="flex items-center gap-2">
                          <span className="text-xs w-12">{name}:</span>
                          <input
                            type="password"
                            className="flex-1 rounded border px-2 py-1 text-xs"
                            placeholder="New PIN (4-8 digits)"
                                                         onKeyPress={(e) => {
                               if (e.key === 'Enter') {
                                 const newPin = e.target.value.trim();
                                 if (newPin && /^[0-9]{4,8}$/.test(newPin)) {
                                   // Check if PIN is the same as current
                                   if (newPin === pins[name]) {
                                     alert(`New PIN cannot be the same as ${name}'s current PIN. Please choose a different PIN.`);
                                     e.target.value = "";
                                     return;
                                   }
                                   
                                   // Check if another roommate has this PIN
                                   const existingUser = roommates.find(roommate => roommate !== name && pins[roommate] === newPin);
                                   if (existingUser) {
                                     alert(`PIN ${newPin} is already in use. Please choose a different PIN.`);
                                     e.target.value = "";
                                     return;
                                   }
                                   
                                   const confirmPin = prompt(`Confirm new PIN for ${name} (4-8 digits):`);
                                   if (confirmPin === newPin) {
                                     setState((s) => ({ 
                                       ...s, 
                                       pins: { ...s.pins, [name]: newPin } 
                                     }));
                                     e.target.value = "";
                                     alert(`${name}'s PIN has been updated to ${newPin}`);
                                   } else if (confirmPin !== null) {
                                     alert("PINs don't match. PIN change cancelled.");
                                     e.target.value = "";
                                   }
                                 } else {
                                   alert("PIN must be 4-8 digits.");
                                   e.target.value = "";
                                 }
                               }
                             }}
                          />
                          <button 
                            className="px-2 py-1 bg-blue-600 text-white rounded text-xs"
                            onClick={() => {
                              const newPin = prompt(`Enter new PIN for ${name} (4-8 digits):`);
                              if (newPin && /^[0-9]{4,8}$/.test(newPin)) {
                                // Check if PIN is the same as current
                                if (newPin === pins[name]) {
                                  alert(`New PIN cannot be the same as ${name}'s current PIN. Please choose a different PIN.`);
                                  return;
                                }
                                
                                // Check if another roommate has this PIN
                                const existingUser = roommates.find(roommate => roommate !== name && pins[roommate] === newPin);
                                if (existingUser) {
                                  alert(`PIN ${newPin} is already in use. Please choose a different PIN.`);
                                  return;
                                }
                                
                                const confirmPin = prompt(`Confirm new PIN for ${name} (4-8 digits):`);
                                if (confirmPin === newPin) {
                                  setState((s) => ({ 
                                    ...s, 
                                    pins: { ...s.pins, [name]: newPin } 
                                  }));
                                  alert(`${name}'s PIN has been updated to ${newPin}`);
                                } else if (confirmPin !== null) {
                                  alert("PINs don't match. PIN change cancelled.");
                                }
                              } else if (newPin !== null) {
                                alert("PIN must be 4-8 digits.");
                              }
                            }}
                          >
                            Set
                          </button>
                        </div>
                      ))}
                    </div>
                    <div className="space-y-2">
                      <div className="grid grid-cols-2 gap-2">
                        <button 
                          className="px-3 py-2 bg-red-600 text-white rounded-lg text-sm"
                          onClick={() => {
                            if (confirm("Reset all credits to 0?")) {
                              setState((s) => ({ ...s, credits: Object.fromEntries(Object.keys(s.credits).map((k) => [k, 0])) }));
                              setShowAdminPanel(false);
                            }
                          }}
                        >
                          Reset Credits
                        </button>
                        <button 
                          className="px-3 py-2 bg-orange-600 text-white rounded-lg text-sm"
                          onClick={() => {
                            if (confirm("Clear all history? This will remove all past actions but keep current credits and queues.")) {
                              setState((s) => ({ ...s, history: [] }));
                              setConflicts([]); // Also clear conflicts since they're based on history
                              setShowAdminPanel(false);
                            }
                          }}
                        >
                          Reset History
                        </button>
                      </div>
                      <div className="grid grid-cols-2 gap-2">
                        <button 
                          className="px-3 py-2 bg-yellow-600 text-white rounded-lg text-sm"
                          onClick={() => {
                            if (confirm("Reset queues to default order? This will put everyone back to their original positions.")) {
                              setState((s) => ({ 
                                ...s, 
                                queue3pm: defaultState.queue3pm,
                                queueNight: defaultState.queueNight 
                              }));
                              setShowAdminPanel(false);
                            }
                          }}
                        >
                          Reset Queues
                        </button>
                        <button 
                          className="px-3 py-2 bg-red-800 text-white rounded-lg text-sm"
                          onClick={() => {
                            const adminPin = prompt("Enter admin PIN to reset everything:");
                            if (adminPin === "2024") {
                              if (confirm("Reset everything? This will clear all data and reset PINs to default.")) {
                                localStorage.removeItem(STORAGE_KEY);
                                window.location.reload();
                              }
                            } else if (adminPin !== null) {
                              alert("Incorrect admin PIN. Reset cancelled.");
                            }
                          }}
                        >
                          Reset Everything
                        </button>
                        <button 
                          className="px-3 py-2 bg-purple-600 text-white rounded-lg text-sm"
                          onClick={() => {
                            if (confirm("Reset bathroom assignments to default?")) {
                              setState((s) => ({ 
                                ...s, 
                                bathrooms: defaultState.bathrooms 
                              }));
                              alert("Bathroom assignments reset to default.");
                            }
                          }}
                        >
                          Reset Bathrooms
                        </button>
                      </div>
                    </div>
                    <button 
                      className="w-full px-4 py-2 bg-gray-300 rounded-lg"
                      onClick={() => {
                        setShowAdminPanel(false);
                      }}
                    >
                      Close
                    </button>
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<DishwasherApp />);
  </script>
</body>
</html>
